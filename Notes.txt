[*_Alttaki Notlar Yazýlým Yaklaþýmlarýndaki Detay Noktalarý Ýçermektedir_*]


*_) Yazýlýmda en zor þey; anlama, anlatma ve iletiþimdir. Bu metimdeki notlar bu sorunlarýn çözümlerini içermektedir.

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>




#]*_Software Philosophy_*[#

*_Programing Languages_*
0_) Programlama dilleri, program geliþtirme yaklaþýmlarýna göre farklý kategorilere ayrýlýrlar. 
    Bu ayrým dillerin derlenme þekilleri(Compiling and Interpreting) olabilir, 
    uygulama geliþtiriciyi makine dilinden ne düzeyde soyutladýðý olabilir, 
    hangi tür kodlama yaklaþýmý(Procedurel, OOP vb.) kullandýðý olabilir
    ve Imperative-Declerative yaklaþým gibi daha birçok metrik vardýr.
    Programlama dilleri yukarada sayýlan ve sayýlmayan bir çok metriðin bazýlarýný destekler, bazýlarýný desteklemez, bazýlarýný kýsmen, bazýlarýný hibrit yapýlarla destekler.
    Yukarýda bahsedilen yaplaþýmlarý programlama dünyasýna tam manasýyla giriþ yapmadan ve tecrübe etmeden akýlda kategorileþtirmek ve özümsemek çok zordur!

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>





#]*_OOP(Object Oriented Programing)_*[#

*_OOP Philosophy_*
0_) Program an interface, not an implementation(Arayüzlere programlama yap, gerçekleþtirmelere deðil)[Gerçekleþtirme: Sýnýf new'lemedir]
0_) Depend on abstructions, not on concretions(Arayüzlere baðýmlý ol, gerçekleþtirmelere deðil)[Gerçekleþtirme: Sýnýf new'lemedir]



*_Class-Object Informations_*
0_)   Class yapýlarý felsefi olarak insanlarýn idrak ettikleri dünyayý elektronik sistemlerde anlaþýlmasý kolay þekilde modellemek için kullandýklarý yapýlardýr.
1_)   Class-Object farký; 	
1.1_) Class bir þablondur ve objeler bu þablondan türetilirler.
1.2_) Class : Sadece HardDisk üzerinde(yani elektronik cihazýn depolama alanýnda yer kaplayan) bulunan yapýlardýr.
1.3_) Object(Nesne) : Class'tan türetilen ve Ram üzerinde yer kaplayan yapýlardýr, bu nedenledir ki nesne yapýlarý için yaþayan yapýlar denir.



*_Class yazma Standartlarý_*
1_) Bir Class içinde doðrudan assignment(atama) iþlemi yapýlmaz, eðer atama iþlemi yapýlacaksa sýnýfýn kurucusunda bu atama iþlemi yapýlýr.
2_) Bir metod'a dörtten fazla parametre geçiliyorsa bu parametreler bir model olarak paketlenmelidir(bazý istisnai durumlar dýþýnda bu kurala uyulmalýdýr).



*_Behaviors(Function&Method)_*
0_)   Programlama dillerindeki yaklaþýma göre dillerdeki iþlevselliklere function(fonksiyon) ya da method(metod) denir.
0.1_) Function(fonksiyon) : Genellikle procedurel(C, Kýsmen C++ vb.) temelli dillerde tek baþýna tanýmlanan iþlevselliklerdir.
0.2_) Method(Metod) : OOP(Nesne yönelimli) temelli dillerde sýnýf yapýlarýnýn içerisinde tanýmlanan iþlevselliklerdir.
0.3_) Kýsaca: Class yapýlarýnýn içinde kullanýlýnca 'Method' olarak isimlendirilir, bir Class yapýsýna baðlý olmadan kullanýlýnca 'Fonksiyon' olarak isimlendirilir.


*_Polymorphism_*
0_)   OOP yaklaþýmýnda Method-Class seviyesinde olan çok biçimliliktir. 
0.1_) Method'larýn 'Virtual-Overwride' olarak kullanýlmalarý, metod'larýn çok biçimli olmalarýný saðlar.
0.2_) 'Implementation-Inheritance' yaklaþýmý 'Upcasting' kullanýmý ile sýnýf seviyesinde çok biçimliliðin kullanýlmasýný saðlar.
* Upcasting: Bir ata Class ya da Interface deðiþkenine kendini inherid(ya da implement) eden sýnýfýn nesnesinin atanmasý iþlemidir.



>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>





#]*_Software Architectures_*[#

*_UML-Class Diagrams_*
1_) Is A Relationship(Generalization-Specialization, Inheritance-Implementation) : Kalýtým iliþkilerini gösterir. 'Inheritance, Implementation' farklý olarak 'Generalization, Specialization' olarakta isimlendirilir.
2_) Has A Relationship(Association): Bir sýnýfýn baþka bir sýnýf içinde property olarak kullanýlma iliþkilerini gösterir.
    'Has A' iliþkilerinin temelde "one-one, one-many, many-many" gibi üç adet türü vardýr.
3_) Association: Bilme, Generalization-Specialization: Kalýtým iliþkileridir.
4_) Association iliþkilerin bir ileri türleri, Aggregation ve Composition iliþkileridir.



*_Design Patterns(Tasarým Desenleri)_*
0_) Aslýnda Tarasým desenleri kýsaca Nesneler arasýndaki iliþkileri yönetmektir ya da birden fazla nesnenin nasýl yönetileceðidir.
1_) Bir tasarým deseni "Name, Problem, Solution, Result" olmak üzere dört kademeden ibaretttir.

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>



#]*_Software Architectures Layers_*[#

*_Data Access Layer_*
0_) Bu katmanda veri kaynaklarýna eriþim ile ilgili iþlemler yapýlýr.
1_) ORM(Object Relation Mapping): Veritabanýna eriþimi saðlayan ve veritabaný tablolarýnýn programlama tarafýndaki karþýlýðý sýnýflar ile yönetilmesini saðlayan teknolojilerdir.
1.1_) Mapping: Veritabaný tablolarýnýn programlama tarafýndaki karþýlýðý olan sýnýflarý yönetmek için kullanýlan(anahtar kolonu, colon adý vb. belirlemek) yönergeler.
1.2_) Context(EF)-Session(Hibernate)-vb.: Veritabaný baðlantýsýnýn saðlanmasýný saðlayan sýnýflardýr.
2_) Micro ORM: Ýlgili teknoloji platformunda veritabaný baðlantýsý saðlayan sýnýflarýn üzerinden veritabaný iþlemlerinin ORM yapýlarýndan daha basit yaplaþýmla yapan yaklaþýmlardýr. ORM yaklaþýmýndan daha hýzlýdýr.






>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>







#]*_Software Test(TDD-TFD)_*[#


0_) Mimari tasarýmda "Business Layer ve UI Layer" katmaný için testlerin yapýlmasý yeterlidir.
    Temel olarak yazýlým testleri dört evreden oluþur, "Unit Test-Integrated Test-System Test-Application Test"
1_) Unit Test: Kodu yazan kiþi tarafýndan yapýlýr. Unit Tast yazabilmak için yazýlýmýn SOLID standartlarýný büyük ölçüde saðlamasý gerekir.
2_) Integrated Test: 
3_) System Test: Yük-Performans-stres testlerinden oluþur 
4_) Application Test: Klasik kullanýcý testleridir, Kabul Testi olarak'ta adlandýrýlýr.




>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
_Düzenle_

* SoC(Separation Of Concerns): SoC, yazýlýmdaki elemanlarýn kendilerine özel olmasýný, sorumluluklarýnýn kendilerine ait olup, baþka elemanlar ile paylaþmamasýný söyler. Yazýlým içindeki bileþenlerin bir birine baðlýlýk derecesi(coupling) ve bileþenler içerisindeki sorumluluk iliþksi(cohesion), 
SoC prensibi için önemli iki kavramdýr. Bileþenlerin baðlýlýk derecesinin düþük olmasý ve bir bileþen içindeki sorumluluk iliþkisinin yüksek olmasý her zaman tercih edilmelidir. Yani low-coupling, high-cohesion olmazsa olmaz!

* AOP(Aspect Oriented Programming): Aspect Oriented Programming’in odak noktasý ise konularýn ayrýmýdýr (Separation of Concerns). Object Oriented Programming’de soyutlamaya (Abstraction) giderekte kodun tekrar kullanýlabilirliðini, okunabilirliðini ve geniþletilebilirliðini ve sýnýflarýn birbirine sýký sýkýya baðlý (Tightly Coupled) olmamasýný saðlayabiliriz ama bir noktaya kadar. O nokta geldiðinde ise AOP kesiþen ilgilerimizi ele alarak onlarý tamamen baðýmsýz (Independent) hale getirmektedir. Bu sayede her bir kesiþen ilgimiz, kendi içerisinde baðýmsýz olarak geliþtirilebilir ve tekrar kullanýlabilir hale gelmektedir.

* CCC(Cross Cutting Concern)[Enine(Çapraz) Kesiþen Ýlgiler]: Yazýlýmlarýn kod tabanlarý incelendiðinde, bazý noktalarýn(ilgilerin) farklý katman ve modüllerde sürekli tekrar ettiði farkedilir.Mesela exception handling, transactionlar, güvenlik kontrolleri, caching, loglama vb. gibi ilgiler(concern) yazýlýmlarýn en çok tekrarlanan kýsýmlarýndan bazýlarý. Bu ilgiler literatürde cross-cutting concerns olarak geçmekte.

* IOC(Inversion Of Control): Uygulama içerisindeki nesne yaratma sürecinin sizden alýnmasý ve bunun bir çatýya (framework) devredilmesine Inversion of Control denir.
** 'DI(Dependency Injection)-IOC(Inversion Of Control)-DI(Dependency Inversion)' kavramlarý bir birleriyle baðlantýlý konulardýr ve SOLID prensiplerinin 'D' harfi ile ilgilidir.












